\chapter{Resultados}
\label{ch:resultados}

En este capítulo se expondrán los resultados obtenidos al aplicar la metodología descrita en el capítulo \ref{ch:metododetrabajo} para el desarrollo del presente PFC.

Se muestra todo el proceso de desarrollo real que se ha seguido hasta la obtención del sistema real, desde su fase de inicio hasta su finalización, mostrando la evolución del sistema de manera incremental y la evolución de requisitos funcionales que ha sufrido.

Siguiendo la metodología propuesta por el Proceso Unificado de Desarrollo, el ciclo de vida de desarrollo del sistema se ha dividido en las cuatro fases que el PUD propone: Inicio, Elaboración, Construcción y Transición. Cada una de esas fases, a su vez, se ha dividido en una o más iteraciones, donde intervienen las disciplinas de Captura de Requisitos, Análisis, Diseño, Implementación y Pruebas. De este modo, el sistema va incrementando su funcionalidad al terminar cada una de estas iteraciones.

En las sucesivas secciones se detallan cada una de las fases del PUD aplicadas al desarrollo del sistema, las iteraciones que abarca y se expondrá la evolución que ha ido sufriendo el proyecto hasta obtener el resultado final. 

\section{Fase de Inicio}

La fase de inicio abarca una única iteración, en la cuál, como se indica en esta fase del PUD (ver sección \ref{lbl:inicio}), se llevarán a cabo las siguientes tareas:

\begin{itemize}
	\item Identificación de requisitos funcionales y no funcionales del sistema a desarrollar.
	\item Elaboración de un primer modelo de casos de uso.
  \item Análisis de viabilidad y riesgos.
  \item Elaboración del plan de iteraciones (o plan de proyecto) para el resto de fases.
\end{itemize}

En esta fase, como se muestra en la Figura \ref{fig:pudInicio}, interviene principalmente la disciplina de Captura de Requisitos. 

\imagenBorde{Cap5//pudInicio}{1.0}{Fase de inicio en el PUD}{fig:pudInicio}

En los siguientes apartados se exponen las tareas realizadas en esta fase.

\subsection{Identificación de requisitos}

Para la identificación de requisitos del sistema, se estudió la literatura existente relacionada con el tema y se fueron extrayendo requisitos funcionales que pudieran resolver o mitigar los desafíos encontrados en la literatura, desarrollados en el capítulo \ref{ch:estadodelarte}. 

Por otra parte, para que el sistema obtenido como resultado del desarrollo de este proyecto pudiera tener una aplicación real, era necesario conocer realmente el funcionamiento de las empresas que siguen el paradigma de GSD y qué información es relevante para los miembros de los equipos de desarrollo. La información que interesaba conocer era cómo se distribuyen los proyectos, los tipos de roles que participan en el desarrollo, experiencia de los desarrolladores, cómo se distribuyen los equipos en los países, cómo se comunican e intercambian información, etc.

Para poder conocer esta información acerca del dominio de aplicación del sistema, se realizaron reuniones con expertos, en este caso la directora del presenta PFC para poder conocer dicha información. Además, también se ha utilizado la propia experiencia del autor y desarrollador del presente PFC en una empresa con centros de desarrollo distribuidos en diferentes países.

Una vez estudiada la literatura, conocidos los problemas del GSD y con conocimiento del dominio de la aplicación del sistema, se pasó a elaborar una serie de requisitos funcionales que el sistema debe cumplir para alcanzar los objetivos propuestos (ver Capítulo \ref{ch:motivacionyobjetivos}).


\subsubsection{Requisitos funcionales}

A continuación, se enumera el conjunto de requisitos funcionales que es sistema debe cumplir.

\begin{itemize}
	\item Se debe permitir que diferentes miembros de los equipos de desarrollo de una compañía puedan acceder al sistema, mediante un nombre de usuario y contraseña, proporcionada por la empresa.
	\item Como en los equipos de desarrollo existen diferentes roles entre sus miembros, el sistema debe adaptarse a las acciones que cada miembro del equipo (en adelante, usuario) puede realizar, según su rol.
	\item La herramienta debe mostrar, de una manera gráfica e intuitiva, el conjunto de decisiones (conocimiento, en este caso) que han sido tomadas en un proyecto software. Además, se deberá proporcionar diferente información acerca de esas decisiones: su autor, centro de desarrollo y compañía donde pertenece, detalles de esa decisión, etc.
	\item Los usuarios pueden participar activamente en las decisiones que se van tomando durante el ciclo de vida de los proyectos en los que participan, de tal modo que la herramienta debe permitir gestionar estas decisiones. Así, se podrán crear, modificar y eliminar dichas decisiones, agrupadas en tres categorías: \textit{Temas}, \textit{Propuestas} y \textit{Respuestas}.
	\item Se deben poder dar de alta nuevos proyectos en el sistema, así como modificar los existentes.
	\item La herramienta debe proveer mecanismos de comunicación síncrona y asíncrona que faciliten la comunicación entre usuarios:
	\begin{itemize}
	\item Se debe crear un sistema de notificaciones, informando al usuario cuando se producen cambios sobre las decisiones de los proyectos donde trabaja.
	\item Se deben mostrar cambios en tiempo real, es decir, si un empleado se encuentra visualizando el conocimiento en la aplicación y, en ese momento, otro empleado de otra localización diferente realiza un cambio sobre el mismo conocimiento, éste debe ser notificado al primer empleado en tiempo real, actualizando su
vista. 
	\end{itemize}
	\item La herramienta debe poder configurarse y mostrarse en diferentes idiomas.
	\item La herramienta debe generar \textbf{logs} con las acciones que se van realizando en el sistema.
	\item Se debe poder exportar el conocimiento a un fichero XML.
\end{itemize}

Además, se identificaron los roles de usuario mostrados en la Tabla \ref{table:roles}, los cuales pueden realizar las acciones mostradas en la Tabla \ref{table:acciones1}.


\subsubsection{Requisitos no funcionales} \label{label:reqnofuncionales}

A continuación, se enumera el conjunto de requisitos no funcionales del sistema, dependientes del entorno tecnológico de la aplicación.

\begin{itemize}
	\item El sistema debe ser distribuido, para facilitar su uso entre los diferentes miembros de los equipos de desarrollo que se encuentran geográficamente deslocalizados. Por tanto, es un sistema cliente/servidor, formado por dos subsistemas.
	\item Debe existir una base de datos que permita almacenar todas las decisiones tomadas en los proyectos, la información de los proyectos, la información de usuarios, etc. 
\end{itemize}

\subsection{Modelo de casos de uso}

% Agrupar los requisitos anteriores en casos de uso

Una vez identificados los requisitos funcionales del sistema, éstos se modelan en un diagrama de casos de uso con un alto nivel de abstracción, solamente mostrando los diferentes grupos funcionales de la herramienta, como se observa en la Figura \ref{fig:casosUsoAlto1}.

A continuación, se muestran los diagramas de casos de uso cada uno de los grandes grupos funcionales de manera más detallada.

% Tener en cuenta los dos sistemas

\paragraph{Acceso al sistema}

\paragraph{Visualización de conocimiento}

\paragraph{Generación de decisiones}

\paragraph{Gestión de proyectos}

\paragraph{Gestión de notificaciones}

\paragraph{Gestión de idiomas}

%% Quizas solo poner los que se pueden desglosar en varios casos de uso
\paragraph{Generación de logs}


\subsection{Análisis de riesgos}

% Preguntar a Aurora

\subsection{Plan de iteraciones}

Dado que el PUD es centrado en los casos de uso, se utilizan los casos de uso modelados en el paso anterior para poder crear el plan de proyecto, o plan de iteraciones, y llevar a cabo el desarrollo de estos casos de uso en las fases posteriores. Así, se obtienen las siguientes iteraciones, mostradas en la Tabla \ref{table:iteraciones1}. 

\begin{center}
\begin{longtable}%[h]%
%\centering
%\begin{logn}
{| >{\centering\arraybackslash}m{4cm} | >{\arraybackslash}m{2cm} | >{\arraybackslash}m{8cm} |}
	\hline
		\multicolumn{1}{|c|}{\cellcolor[gray]{0.4}\textbf{Fase}} &
			\multicolumn{1}{|c|}{\cellcolor[gray]{0.4}\textbf{Iteración}} &
		\multicolumn{1}{|c|}{\cellcolor[gray]{0.4}\textbf{Tareas a realizar}} \\
	\hline
	\endfirsthead
	
	\multicolumn{1}{|c|}{\cellcolor[gray]{0.4}\textbf{Fase}} &
			\multicolumn{1}{|c|}{\cellcolor[gray]{0.4}\textbf{Iteración}} &
		\multicolumn{1}{|c|}{\cellcolor[gray]{0.4}\textbf{Tareas a realizar}} \\
		\hline
		\endhead
		
	\multicolumn{1}{|c|}{\cellcolor[gray]{0.9}Inicio} & 1 &
		 Se identifican los requisitos \newline 
		 Se crea un glosario de términos \newline
		 Se analiza la viabilidad del proyecto \newline
		 Se realiza el plan de iteraciones 
		 Modelo de casos de uso \newline 
		 Glosario de términos \newline
		 Descripción de riesgos \newline
		 Plan de proyecto \\
	\hline
	\multirow{-2}{*}{Elaboración} \cellcolor[gray]{0.9} & 2 &
		 Se crea un modelo de casos de uso detallado \newline 
		 Se diseña la arquitectura \newline
		 Se crea un modelo de clases de análisis \newline
		 Se realiza el modelo de diseño 
		 Modelo de casos de uso detallado \newline 
		 Modelo de Diseño \newline
		 Arquitectura del sistema \newline
		 Modelo de Análisis \\ \hline
		 \cellcolor[gray]{0.9} & 3 & Se crea un modelo de casos de uso detallado \newline 
		 Se diseña la arquitectura \newline
		 Se crea un modelo de clases de análisis \newline
		 Se realiza el modelo de diseño 
		 Modelo de casos de uso detallado \newline 
		 Modelo de Diseño \newline
		 Arquitectura del sistema \newline
		 Modelo de Análisis \\
	\hline
	\multirow{-3}{*}{Construcción} \cellcolor[gray]{0.9} & 4 &
		 Se crea un modelo de casos de uso detallado \newline 
		 Se diseña la arquitectura \newline
		 Se crea un modelo de clases de análisis \newline
		 Se realiza el modelo de diseño 
		 Modelo de casos de uso detallado \newline 
		 Modelo de Diseño \newline
		 Arquitectura del sistema \newline
		 Modelo de Análisis \\ \hline
		 \cellcolor[gray]{0.9} & 5 & 
		 Se crea un modelo de casos de uso detallado \newline 
		 Se diseña la arquitectura \newline
		 Se crea un modelo de clases de análisis \newline
		 Se realiza el modelo de diseño 
		 Modelo de casos de uso detallado \newline 
		 Modelo de Diseño \newline
		 Arquitectura del sistema \newline
		 Modelo de Análisis \\ \hline
		 \cellcolor[gray]{0.9} & 6 & 
		 Se crea un modelo de casos de uso detallado \newline 
		 Se diseña la arquitectura \newline
		 Se crea un modelo de clases de análisis \newline
		 Se realiza el modelo de diseño 
		 Modelo de casos de uso detallado \newline 
		 Modelo de Diseño \newline
		 Arquitectura del sistema \newline
		 Modelo de Análisis \\ 
	\hline
	\multicolumn{1}{|c|}{\cellcolor[gray]{0.9}Transición} & 7 &
		 Se identifican los requisitos \newline 
		 Se crea un glosario de términos \newline
		 Se analiza la viabilidad del proyecto \newline
		 Se realiza el plan de iteraciones 
		 Modelo de casos de uso \newline 
		 Glosario de términos \newline
		 Descripción de riesgos \newline
		 Plan de proyecto \\
	\hline

\caption{Plan de iteraciones}
\label{table:iteraciones1} 
\end{longtable}
\end{center}



\section{Fase de Elaboración}

En esta fase intervienen las disciplinas de Captura de Requisitos, Análisis, Diseño, Implementación y Pruebas, con mayor o menor influencia, según la iteración donde nos encontremos (ver Figura \ref{fig:pudElaboracion}). 

\imagenBorde{Cap5//pudElaboracion}{1.0}{Fase de elaboración en el PUD}{fig:pudElaboracion}

Por ello, esta fase se ha divido en dos iteraciones: la primera de ellas se centra de nuevo en la captura de requisitos, en el análisis y en algunas tareas de diseño. La segunda iteración se centra en el diseño, la implementación y pruebas de un requisito funcional básico del sistema.

Las tareas que se llevan a cabo en esta fase son:

\begin{itemize}
	\item \textbf{Primera iteración}
	\begin{itemize}
		\item Identificación de nuevos requisitos funcionales del sistema.
		\item Elaboración del modelo de casos de uso definitivo.
		\item Elaboración del plan de proyecto definitivo.
	  \item Modelo de clases de análisis de los casos de uso.
	  \item Definición y diseño de la arquitectura del sistema.
	\end{itemize}
	\item \textbf{Segunda iteración}
	\begin{itemize}
		\item Modelo de alto nivel de clases de diseño.
		\item Modelado y diseño de la base de datos.
		\item Definición del diagrama de secuencia correspondiente a la funcionalidad de acceso al sistema.
		\item Implementación de la funcionalidad de acceso al sistema.
		\item Creación de casos de prueba para dicho caso de uso implementado.
	\end{itemize}
\end{itemize}


\subsection{Primera iteración}

\subsubsection{Identificación de requisitos}

Al terminar la iteración de la fase anterior, obteniendo un primer modelo de casos de uso con los requisitos identificados, se llevó a cabo una reunión de seguimiento, para revisar la planificación realizada y poder identificar nuevos requisitos funcionales, si los hubiera.

Como resultado de esta reunión, se identificaron nuevos requisitos funcionales para añadir el sistema y que servirán para mitigar o resolver más problemas que aparecen en GSD. Estos nuevos requisitos son:

\begin{itemize}
	\item Además de poder mostrar las decisiones tomadas en un proyecto, se debe poder aceptar o rechazar dichas decisiones, para posteriormente, cuando el proyecto llegue a su fin, poder conocer qué notificaciones fueron de ayuda y cuáles no. 
	\item Para aumentar el conocimiento que se genera al crear nuevas decisiones de un proyecto, se debe poder adjuntar ficheros a dichas decisiones, para potenciar y ampliar la información que producen al proyecto. Del mismo modo, se deben poder descargar esos archivos adjuntos, si los hay.
	\item Cuando se presenta un nuevo proyecto, se debe poder aconsejar decisiones tomadas en proyectos ya terminados, que tuviesen características similares.
	\item Se deben poder generar de manera automática estadísticas que ayuden a llevar un control sobre los proyectos que se están desarrollando por los diferentes centros de desarrollo software de una compañía. También se podrán generar estadísticas acerca de los miembros de los equipos.
	\item Se deben poder generar informes de las decisiones tomadas en un proyecto, en forma de tabla y de manera automática. Dicho informe debe generarse como un documento PDF.
\end{itemize}

Con estos nuevos requisitos, se actualizan las acciones que pueden realizar los diferentes roles de usuarios (ver Tabla \ref{table:acciones2}), así como el modelo de casos de uso, explicado en el siguiente apartado.

\subsubsection{Modelo de casos de uso}

En la Figura \ref{fig:casosUsoAlto2} se muestra el diagrama de casos de usos global, incluyendo los nuevos requisitos.

A continuación se detallan los nuevos casos de uso.

\paragraph{Aceptación de decisiones}

\paragraph{Adjuntar ficheros}

\paragraph{Aconsejar decisiones}

\paragraph{Generación de estadísticas}

\paragraph{Generación de informes}


\subsubsection{Plan de iteraciones}

Una vez identificados nuevos requisitos y modelados los casos de uso del sistema con esos nuevos requisitos, se reorganiza el plan de proyecto con nuevas iteraciones, para poder tener en cuenta el desarrollo de los nuevos casos de uso. Por tanto, a partir de las iteraciones planificadas en la Tabla \ref{table:iteraciones1}, se obtiene el nuevo plan de iteraciones mostrado en la Tabla \ref{table:iteraciones2} (teniendo en cuenta que la fase de inicio ya se ha completado).

\begin{center}
\begin{longtable}%[h]%
%\centering
%\begin{logn}
{| >{\centering\arraybackslash}m{4cm} | >{\arraybackslash}m{2cm} | >{\arraybackslash}m{8cm} |}
	\hline
		\multicolumn{1}{|c|}{\cellcolor[gray]{0.4}\textbf{Fase}} &
			\multicolumn{1}{|c|}{\cellcolor[gray]{0.4}\textbf{Iteración}} &
		\multicolumn{1}{|c|}{\cellcolor[gray]{0.4}\textbf{Tareas a realizar}} \\
	\hline
	\endfirsthead
	
	\multicolumn{1}{|c|}{\cellcolor[gray]{0.4}\textbf{Fase}} &
			\multicolumn{1}{|c|}{\cellcolor[gray]{0.4}\textbf{Iteración}} &
		\multicolumn{1}{|c|}{\cellcolor[gray]{0.4}\textbf{Tareas a realizar}} \\
		\hline
		\endhead
		
	\multicolumn{1}{|c|}{\cellcolor[gray]{0.9}Inicio} & 1 &
		 Se identifican los requisitos \newline 
		 Se crea un glosario de términos \newline
		 Se analiza la viabilidad del proyecto \newline
		 Se realiza el plan de iteraciones 
		 Modelo de casos de uso \newline 
		 Glosario de términos \newline
		 Descripción de riesgos \newline
		 Plan de proyecto \\
	\hline
	\multirow{-2}{*}{Elaboración} \cellcolor[gray]{0.9} & 2 &
		 Se crea un modelo de casos de uso detallado \newline 
		 Se diseña la arquitectura \newline
		 Se crea un modelo de clases de análisis \newline
		 Se realiza el modelo de diseño 
		 Modelo de casos de uso detallado \newline 
		 Modelo de Diseño \newline
		 Arquitectura del sistema \newline
		 Modelo de Análisis \\ \hline
		 \cellcolor[gray]{0.9} & 3 & Se crea un modelo de casos de uso detallado \newline 
		 Se diseña la arquitectura \newline
		 Se crea un modelo de clases de análisis \newline
		 Se realiza el modelo de diseño 
		 Modelo de casos de uso detallado \newline 
		 Modelo de Diseño \newline
		 Arquitectura del sistema \newline
		 Modelo de Análisis \\
	\hline
	\multirow{-3}{*}{Construcción} \cellcolor[gray]{0.9} & 4 &
		 Se crea un modelo de casos de uso detallado \newline 
		 Se diseña la arquitectura \newline
		 Se crea un modelo de clases de análisis \newline
		 Se realiza el modelo de diseño 
		 Modelo de casos de uso detallado \newline 
		 Modelo de Diseño \newline
		 Arquitectura del sistema \newline
		 Modelo de Análisis \\ \hline
		 \cellcolor[gray]{0.9} & 5 & 
		 Se crea un modelo de casos de uso detallado \newline 
		 Se diseña la arquitectura \newline
		 Se crea un modelo de clases de análisis \newline
		 Se realiza el modelo de diseño 
		 Modelo de casos de uso detallado \newline 
		 Modelo de Diseño \newline
		 Arquitectura del sistema \newline
		 Modelo de Análisis \\ \hline
		 \cellcolor[gray]{0.9} & 6 & 
		 Se crea un modelo de casos de uso detallado \newline 
		 Se diseña la arquitectura \newline
		 Se crea un modelo de clases de análisis \newline
		 Se realiza el modelo de diseño 
		 Modelo de casos de uso detallado \newline 
		 Modelo de Diseño \newline
		 Arquitectura del sistema \newline
		 Modelo de Análisis \\ 
	\hline
	\multicolumn{1}{|c|}{\cellcolor[gray]{0.9}Transición} & 7 &
		 Se identifican los requisitos \newline 
		 Se crea un glosario de términos \newline
		 Se analiza la viabilidad del proyecto \newline
		 Se realiza el plan de iteraciones 
		 Modelo de casos de uso \newline 
		 Glosario de términos \newline
		 Descripción de riesgos \newline
		 Plan de proyecto \\
	\hline

\caption{Plan de iteraciones actualizado}
\label{table:iteraciones2} 
\end{longtable}
\end{center}


\subsubsection{Análisis de casos de uso}

El modelo de casos de uso obtenido se especifica de manera más formal y en detalle, describiendo el funcionamiento de cada caso de uso y sus escenarios. Además, para cada uno de ellos, se crea el diagrama de clases de análisis, que representa las acciones que se llevan a cabo entre las clases identificadas para dar soporte a cada caso de uso. Existen tres tipos de clase: 

\begin{enumerate}
	\item Interfaz o \textit{Boundary}: representa clases utilizadas para la comunicación entre el actor y el sistema.
	\item Control: representa clases y objetos de control. Es la que controla y coordina el flujo (o escenario) de funcionamiento del caso de uso.
	\item Entidad o \textit{Entity}: son clases que representan objetos de información persistentes del sistema.
\end{enumerate}


% Para algunos casos de uso (los primeros), poner en tabla el flujo (escenarios) y el diagrama de análisis
\paragraph{Acceso al sistema}

\paragraph{Visualización de conocimiento}

\paragraph{Generación de decisiones}

\paragraph{Gestión de proyectos}

\paragraph{Gestión de notificaciones}

\paragraph{Gestión de idiomas}


Del mismo modo se definen los escenarios de los casos de uso y sus diagramas de clases de análisis en los siguientes grupos funcionales:

% LISTA

Se ha decidido no incorporar todos los diagramas al documento por la gran cantidad de diagramas que existen, para no aumentar excesivamente la longitud del documento.


\subsubsection{Arquitectura del sistema}

Al final de esta primera iteración de la fase de elaboración, se comienza con el diseño del sistema. En este caso se define y diseña su arquitectura. En posteriores iteraciones y fases, se continuará con la labor de diseño del sistema, creando los diagramas de secuencia para cada caso de uso y el diagrama de clases de diseño, siendo la base para la posterior implementación.

\paragraph{Arquitectura cliente-servidor}

Como se comentó en el apartado \ref{label:reqnofuncionales}, el sistema a desarrollar debe ser distribuido, para poder ser utilizado desde localizaciones diferentes, por lo que se ha decidido utilizar una arquitectura cliente-servidor. De esta forma, el sistema completo se divide en dos subsistemas:

\begin{itemize}
	\item \textbf{Subsistema Cliente}: este subsistema es el utilizado por los miembros de los equipos de desarrollo deslocalizados. Este subsistema es que se encarga de mostrar la interfaz gráfica de usuario, recoger las acciones que el usuario desea hacer y enviar dicha acción al servidor, esperando su respuesta para actualizar la interfaz gráfica en consecuencia.
	\item \textbf{Subsistema Servidor}: este subsistema se encarga de recibir las peticiones del
subsistema cliente, procesarlas, almacenar y recuperar información de su base de datos y enviar
la respuesta al cliente. También se encarga de que todas las acciones queden registradas.
\end{itemize}

Así, cada uno de los subsistemas se puede encontrar en máquinas diferentes, pues, siguiendo la
arquitectura cliente-servidor, se comunican a través de \textbf{RMI} (ver sección \ref{sec:marco}). Además,
la base de datos utilizada por el servidor también se pueden encontrar en una máquina
diferente a la máquina donde se encuentre el servidor. 

Por tanto, algunas ventajas de utilizar este enfoque distribuido siguiendo la arquitectura cliente-servidor son:

\begin{itemize}
	\item Centralización del control: toda la lógica de dominio y control está centralizada en el servidor, por lo que el sistema cliente es totalmente independiente de la implementación
del servidor. Del mismo modo, el sistema cliente es independiente de como se realiza la gestión
del conocimiento en el servidor. Además, los accesos, recursos y la integridad de los datos son
controlados por el servidor de forma que un cliente defectuoso o no autorizado no pueda dañar
el sistema.
	\item Escalabilidad: se pueden añadir nuevos tipos de sistemas clientes para que se comuniquen
con el servidor.
	\item Fácil mantenimiento: al estar los sistemas distribuidos en diferentes máquinas, es posible
reemplazar, reparar o actualizar el servidor, mientras que sus clientes no se verán afectados
por ese cambio.
\end{itemize}

En la Figura \ref{fig:despliegue} se muestra una vista de los subsistemas que integran el sistema global y
como se comunican dichos sistemas a través de interfaces, facilitando la distribución de cada uno
de los sistemas en diferentes máquinas. 

\paragraph{Arquitectura multicapa}

En cuanto a la arquitectura de implementación, ambos sistemas, cliente y servidor, serán desarrollados siguiendo una arquitectura multicapa, de modo que se pueda aislar la capa de presentación de la de la lógica de dominio y ésta de la capa de persistencia (ver Figura \ref{fig:multicapa}).

\imagenBorde{Cap5//multicapa}{1.0}{Arquitectura multicapa}{fig:multicapa}

De este modo, las capas con las que cuenta cada subsistema son las siguientes:

\begin{itemize}
	\item Cliente: comunicaciones, dominio y presentación.
	\item Servidor: comunicaciones, dominio, persistencia y presentación.
\end{itemize}

Más concretamente, estas capas se traducirán a paquetes de implementación, donde cada uno agrupara los siguientes elementos:

\begin{itemize}
	\item \textbf{Comunicaciones}: contiene las clases e interfaces necesarias para la comunicación de los subsistemas a través de RMI.
	\item \textbf{Dominio}: contiene todos los objetos del dominio de la aplicación.
	\item \textbf{Persistencia}: contiene las clases encargadas de gestionar la persistencia de los objetos de dominio.
	\item \textbf{Presentación}: contiene todas las vistas de la interfaz gráfica de usuario, organizadas en subpaquetes. 
\end{itemize}

En la Figura \ref{fig:paquetes} puede observarse esta arquitectura multicapa y las relaciones entre dichas capas.


Utilizando este enfoque multicapa, se sigue el principio de mínimo acoplamiento y máxima
cohesión, desacoplando los elementos de una capa de los de otra. De este modo, se facilita el
mantenimiento y extensibilidad del sistema, pues cuando se realice el cambio en algún elemento
de una capa, el resto de capas no se verán afectadas.


% Patrones utilizados

\subsection{Segunda iteración}

Al finalizar la iteración anterior, en la que se identificaron nuevos requisitos, éstos se añadieron como nuevos casos de uso, se crearon las clases de análisis y se especificó a arquitectura del sistema, se realizó otra reunión de seguimiento, antes de comenzar la nueva iteración, para revisar y validar todos estos artefactos obtenidos.

En dicha reunión, ya no se identificaron más requisitos y se validó el plan de iteraciones y resto de artefactos obtenidos, por lo que en sucesivas iteraciones y fases se comienza con el diseño, implementación y pruebas de los casos de uso identificados.

\subsubsection{Diagrama de clases de diseño}

En esta segunda iteración de la fase de elaboración, se realiza un diagrama de clases de diseño de alto nivel, reflejando los clases de los objetos de dominio y sus relaciones. Este diagrama se irá detallando y refinando durante las iteraciones de la fase de construcción.

En la Figura \ref{fig:clasesDiseño} se puede observar este diagrama de clases de diseño.


\subsubsection{Diseño de la base de datos}

A partir de las clases de dominio y sus relaciones, se modela y diseña la base de datos para que los objetos de dominio puedan ser persistentes y almacenarse en una base de datos. En los siguientes apartados se muestra el modela conceptual y lógico de la base de datos utilizada en el sistema.

\paragraph{Diseño conceptual}

El diseño conceptual de la base de datos del sistema está basado en las clases persistentes de
la lógica del dominio, representando dichas clases y sus relaciones en
un modelo ER (Entidad-Interrelación).

Como dicho modelo es el modelo conceptual (de más alto nivel) en el diseño de una base
de datos, las entidades se corresponden prácticamente con las clases del modelo de dominio, los
atributos de dichas entidades se corresponden con los atributos de las clases, y las relaciones se
corresponden con las asociaciones que existen entre las diferentes clases del modelo de conocimiento
o dominio.

Algunas diferencias que existen entre el modelo de dominio y el modelo ER son:
% No existe una entidad Sustitución, ya que, en el modelo ER, esto se puede modelar como
%una relación entre médicos, con determinados atributos en dicha relación.
% Los diferentes tipos de médico se modelan como una jerarquía de herencia de la entidad Médico,
%no apareciendo la entidad TipoMédico correspondiente a la clase de dominio, pues esta clase
%aparece por la aplicación del patrón Estado, como ya se vió en la capa de dominio del servidor
%front-end (ver sección 3.1.3).

El modelo ER de la base de datos se muestra en la Figura \ref{fig:modeloER}.


\paragraph{Diseño lógico}

Una vez se ha realizado el diagrama ER a partir de las clases y asociaciones del modelo de
dominio del sistema, se debe traducir dicho diagrama a un modelo relacional o de tablas.

Para realizar esto, se han tenido en cuenta las siguientes consideraciones:
% Para representar la jerarquía de herencia de la entidad Usuario y las entidades Administrador,
%Citador y Médico, se ha utilizado el patrón de persistencia \textbf{1 árbol de herencia, 1 tabla},
%por lo que sólo se creará la tabla Usuarios, que agrupará los atributos de todas las entidades
%anteriores. Sin embargo, es necesario añadir un nuevo atributo a la tabla Usuarios para indicar
%el rol del usuario, correspondiente a cada una de las subclases.
%La razón de utilizar dicho patrón es agrupar en única tabla toda la jerarquía de herencia que
%existe entre esas clases en el modelo de dominio, pues ninguna de las clases Administrador,
%Citador ni Médico añaden nuevos atributos a la clase Usuario, por lo que no se van a obtener
%atributos (columnas) nulas en la tabla resultante.
% Para representar los dferentes tipos de médico, aunque en el modelo ER se represente con
%una herencia, por ser un modelo conceptual, la tabla que se obtiene es la tabla TiposMedico,
%obtenida al aplicar el patrón de persistencia 1 árbol de herencia, 1 tabla sobre la clase Tipo
%Médico que aparece en el modelo de dominio. Esta clase, a su vez, proviene de la aplicación del
%patrón Estado, como ya se comentó en la sección frontend.
% En la tabla EntradasLog, obtenida al transformar la entidad EntradaLog en una tabla, la columna
%usuario puede ser vacia, pues hay acciones que no están asociadas a ningún usuario
%del sistema, como, por ejemplo, iniciar el servidor front-end. Además, si se borra el usuario
%asociado a la acción que se realizado, esta columna tomará el valor NULL, pues no se puede
%borrar la entrada de log correspondiente, ya que es un requisito el ir almacenando todas las
%acciones realizadas.

% Trigger


\subsubsection{Diagrama de secuencia}

Una vez se han modelado los objetos de dominio y se ha diseñado la base de datos a utilizar en el sistema, se pasa a desarrollar el caso de uso planificado para esta iteración, que es el caso de uso de acceso al sistema.

Para ello, en primer lugar se modela el funcionamiento de este caso de uso a través de diagramas de secuencia, mostrado en la Figura \ref{fig:secuenciaLogin}.

% Comentar q el usuario y conraseña es porporcionado por la empresa 
% quizas, solo en este diagrama, explicar como funcioan
Una vez se ha modelo el funcionamiento de caso de uso con el diagrama de secuencia, dicho comportamiento se implementa y se prueba, finalizando esta iteración de la fase de elaboración.

\subsubsection{Implementación}

% Comentar que es una funcionalidad básica, de login y logout.
% Que se implemente siguiendo el escenario del diagrama de secuencia
% Modelo de entrada al sistema
% Que en proximas iteractiones no se detallara ranro por extension y se iran obteniendo nuevos incrementos

%Durante esta disciplina se implementan los requisitos de la pila del Sprint
%correspondientes con la Tabla 31. Al finalizar esta disciplina se obtuvieron las clases Java
%que contenían las funcionalidades que hacían posible los requisitos seleccionados.

\subsubsection{Pruebas}
		
		
		
		
		
		
		
		
\section{Fase de Construcción}






\section{Fase de Transición}

En esta fase, compuesta de una única iteración, es donde el producto software se prepara para su entrega al cliente, incluyendo los últimos detalles de implementación y pruebas (ver Figura \ref{fig:pudTransicion}).

Al alcanzar esta última iteración, se prepara la versión ejecutable del producto al cliente, así como se realizan las últimas pruebas globales para comprobar el correcto funcionamiento del sistema. 

Además, se realiza la documentación del producto software y se redactan los manuales de configuración y manuales de usuario del sistema. Dichos manuales pueden encontrarse en los apéndices XXX.